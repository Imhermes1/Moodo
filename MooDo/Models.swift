//
//  Models.swift
//  Moodo
//
//  Created by Luke Fornieri on 18/7/2025.
//

import Foundation
import SwiftUI
import _Concurrency

// MARK: - Data Models

struct Task: Identifiable, Codable, Equatable {
    var id: UUID
    var title: String
    var description: String?
    var isCompleted: Bool
    var isFlagged: Bool
    var isRecurring: Bool
    var priority: TaskPriority
    var emotion: TaskEmotion
    var category: TaskCategory // Added for AI recommendations
    var estimatedTime: Int? // Added for AI recommendations (in minutes)
    var completedAt: Date? // Added for AI learning
    var completedMood: MoodType? // Mood when task was completed
    var reminderAt: Date?
    var deadlineAt: Date? // Separate deadline date from reminder
    var naturalLanguageInput: String?
    var createdAt: Date
    var list: TaskList?
    var tags: [String]
    var subtasks: [Task]?
    var eventKitIdentifier: String? // For linking to EventKit reminder
    var isAIGenerated: Bool // Track if task was generated by AI
    
    init(id: UUID = UUID(), title: String, description: String? = nil, isCompleted: Bool = false, isFlagged: Bool = false, isRecurring: Bool = false, priority: TaskPriority = .medium, emotion: TaskEmotion = .focused, category: TaskCategory = .personal, estimatedTime: Int? = nil, completedAt: Date? = nil, completedMood: MoodType? = nil, reminderAt: Date? = nil, deadlineAt: Date? = nil, naturalLanguageInput: String? = nil, list: TaskList? = nil, tags: [String] = [], subtasks: [Task]? = nil, eventKitIdentifier: String? = nil, createdAt: Date = Date(), isAIGenerated: Bool = false) {
        self.id = id
        self.title = title
        self.description = description
        self.isCompleted = isCompleted
        self.isFlagged = isFlagged
        self.isRecurring = isRecurring
        self.priority = priority
        self.emotion = emotion
        self.category = category
        self.estimatedTime = estimatedTime
        self.completedAt = completedAt
        self.completedMood = completedMood
        self.reminderAt = reminderAt
        self.deadlineAt = deadlineAt
        self.naturalLanguageInput = naturalLanguageInput
        self.createdAt = createdAt
        self.list = list
        self.tags = tags
        self.subtasks = subtasks
        self.eventKitIdentifier = eventKitIdentifier
        self.isAIGenerated = isAIGenerated
    }
    
    // MARK: - Equatable
    static func == (lhs: Task, rhs: Task) -> Bool {
        return lhs.id == rhs.id
    }
}

enum TaskPriority: String, CaseIterable, Codable {
    case low = "low"
    case medium = "medium"
    case high = "high"
    
    var displayName: String {
        switch self {
        case .low: return "Low"
        case .medium: return "Medium"
        case .high: return "High"
        }
    }
    
    var color: Color {
        switch self {
        case .low: return Color(red: 0.22, green: 0.69, blue: 0.42) // Green for low priority
        case .medium: return Color(red: 0.95, green: 0.61, blue: 0.07) // Orange for medium priority
        case .high: return Color(red: 0.91, green: 0.3, blue: 0.24) // Red for high priority
        }
    }
}

// MARK: - Unified Task Emotion System
enum TaskEmotion: String, CaseIterable, Codable {
    case energizing = "energizing"   // Requires high energy (taxes, projects)
    case focused = "focused"         // Requires concentration (writing, analysis)
    case calming = "calming"         // Relaxing tasks (walk, call friend)
    case creative = "creative"       // Creative work (design, brainstorming)
    case routine = "routine"         // Simple tasks (cut grass, organize)
    case stressful = "stressful"     // Demanding tasks (deadlines, presentations)
    
    var displayName: String {
        switch self {
        case .energizing: return "Energizing"
        case .focused: return "Focused"
        case .calming: return "Calming"
        case .creative: return "Creative"
        case .routine: return "Routine"
        case .stressful: return "Stressful"
        }
    }
    
    var icon: String {
        switch self {
        case .energizing: return "bolt"
        case .focused: return "brain.head.profile"
        case .calming: return "leaf"
        case .creative: return "lightbulb"
        case .routine: return "repeat"
        case .stressful: return "exclamationmark.triangle"
        }
    }
    
    var color: Color {
        switch self {
        case .energizing: return Color(red: 0.95, green: 0.61, blue: 0.07) // energizing-orange
        case .focused: return Color(red: 0.4, green: 0.49, blue: 0.92) // focused-blue
        case .calming: return Color(red: 0.22, green: 0.56, blue: 0.94) // calming-blue
        case .creative: return Color(red: 0.56, green: 0.27, blue: 0.68) // creative-purple
        case .routine: return Color(red: 0.22, green: 0.69, blue: 0.42) // routine-green
        case .stressful: return Color(red: 0.91, green: 0.3, blue: 0.24) // stressful-red
        }
    }
}

// MARK: - Task Category System
enum TaskCategory: String, CaseIterable, Codable {
    case work = "Work"
    case personal = "Personal" 
    case health = "Health"
    case shopping = "Shopping"
    case learning = "Learning"
    case finance = "Finance"
    case travel = "Travel"
    case creative = "Creative"
    
    var displayName: String {
        return self.rawValue
    }
    
    var icon: String {
        switch self {
        case .work: return "briefcase"
        case .personal: return "person"
        case .health: return "heart"
        case .shopping: return "cart"
        case .learning: return "book"
        case .finance: return "dollarsign.circle"
        case .travel: return "airplane"
        case .creative: return "paintbrush"
        }
    }
    
    var color: Color {
        switch self {
        case .work: return .blue
        case .personal: return .green
        case .health: return .red
        case .shopping: return .orange
        case .learning: return .purple
        case .finance: return .yellow
        case .travel: return .cyan
        case .creative: return .pink
        }
    }
}



struct MoodEntry: Identifiable, Codable {
    let id: UUID
    var mood: MoodType
    var timestamp: Date
    
    init(id: UUID = UUID(), mood: MoodType, timestamp: Date = Date()) {
        self.id = id
        self.mood = mood
        self.timestamp = timestamp
    }
}

// MARK: - Unified User Mood System
enum MoodType: String, CaseIterable, Codable {
    case energized = "energized"     // High energy, can tackle complex tasks
    case focused = "focused"         // Clear mind, good for detailed work
    case calm = "calm"              // Peaceful, good for routine tasks
    case creative = "creative"       // Inspired, good for brainstorming
    case stressed = "stressed"       // Overwhelmed, needs easy tasks
    case tired = "tired"            // Low energy, minimal tasks only
    
    var displayName: String {
        switch self {
        case .energized: return "Energized"
        case .focused: return "Focused"
        case .calm: return "Calm"
        case .creative: return "Creative"
        case .stressed: return "Stressed"
        case .tired: return "Tired"
        }
    }
    
    var icon: String {
        switch self {
        case .energized: return "bolt.fill"
        case .focused: return "brain.head.profile"
        case .calm: return "leaf"
        case .creative: return "lightbulb"
        case .stressed: return "face.dashed"
        case .tired: return "bed.double"
        }
    }
    
    var color: Color {
        switch self {
        case .energized: return Color(red: 0.95, green: 0.61, blue: 0.07) // energized-orange
        case .focused: return Color(red: 0.4, green: 0.49, blue: 0.92) // focused-blue
        case .calm: return Color(red: 0.22, green: 0.56, blue: 0.94) // calm-blue
        case .creative: return Color(red: 0.56, green: 0.27, blue: 0.68) // creative-purple
        case .stressed: return Color(red: 0.91, green: 0.3, blue: 0.24) // stressed-red
        case .tired: return Color(red: 0.6, green: 0.6, blue: 0.6) // tired-gray
        }
    }
    
    var numericValue: Double {
        switch self {
        case .energized: return 9.0
        case .focused: return 8.0
        case .calm: return 7.0
        case .creative: return 8.5
        case .stressed: return 3.0
        case .tired: return 2.0
        }
    }
    
    // Smart task matching - returns compatible task emotions for this mood
    var compatibleTaskEmotions: [TaskEmotion] {
        switch self {
        case .energized:
            return [.energizing, .focused, .creative]
        case .focused:
            return [.focused, .routine, .creative]
        case .calm:
            return [.calming, .routine]
        case .creative:
            return [.creative, .calming]
        case .stressed:
            return [.calming, .routine]
        case .tired:
            return [.calming]
        }
    }
}

struct VoiceCheckin: Identifiable, Codable {
    let id: UUID
    var transcript: String
    var mood: MoodType?
    var tasks: [String]
    var timestamp: Date
    var duration: TimeInterval
    
    init(id: UUID = UUID(), transcript: String, mood: MoodType? = nil, tasks: [String] = [], duration: TimeInterval = 0) {
        self.id = id
        self.transcript = transcript
        self.mood = mood
        self.tasks = tasks
        self.timestamp = Date()
        self.duration = duration
    }
}



// MARK: - Data Managers

@MainActor
class TaskManager: ObservableObject {
    @Published var tasks: [Task] = []
    @Published var taskLists: [TaskList] = []
    @Published var moodPickerTask: Task? = nil
    let taskScheduler = TaskScheduler()
    let eventKitManager = EventKitManager()
    
    // Performance optimization: Debounce save operations
    private var saveDebounceTimer: Timer?
    private var pendingTasks: [Task] = []
    private var isPerformingBatchOperation = false
    
    var currentMood: MoodType {
        return taskScheduler.currentMood
    }
    
    init() {
        loadFromUserDefaults()
        loadFromCloud()
        
        // Setup notification actions
        EventKitManager.setupNotificationActions()
    }
    
    // MARK: - Optimized Task Operations
    
    func addTask(_ task: Task) {
        var newTask = task
        newTask.id = UUID() // Ensure unique ID
        
        // Batch operation flag for performance
        if !isPerformingBatchOperation {
            print("ðŸ“ Adding task: \(task.title)")
        }
        
        // Immediate UI update (optimistic)
        tasks.append(newTask)
        
        // Enhanced haptic feedback
        HapticManager.shared.taskAdded()
        
        // Handle background operations asynchronously
        _Concurrency.Task {
            var updatedTask = newTask
            
            // Create EventKit reminder if needed
            if task.reminderAt != nil {
                let eventKitID = await eventKitManager.createReminder(for: newTask)
                updatedTask.eventKitIdentifier = eventKitID
            }
            
            // Update the task with any background changes
            await MainActor.run {
                if let index = self.tasks.firstIndex(where: { $0.id == newTask.id }) {
                    self.tasks[index] = updatedTask
                }
                
                // Save in background
                self.debouncedSave()
            }
        }
    }
    
    func addTaskOptimistically(_ task: Task) {
        // This method provides instant UI response for critical actions
        addTask(task)
    }
    
    func addTasks(_ newTasks: [Task]) {
        isPerformingBatchOperation = true
        defer { isPerformingBatchOperation = false }
        
        print("ðŸ“ Batch adding \(newTasks.count) tasks")
        
        // Process tasks with reminders asynchronously
        let tasksWithReminders = newTasks.filter { $0.reminderAt != nil }
        let tasksWithoutReminders = newTasks.filter { $0.reminderAt == nil }
        
        // Add tasks without reminders immediately
        tasks.append(contentsOf: tasksWithoutReminders)
        
        // Process reminder tasks in background
        if !tasksWithReminders.isEmpty {
            _Concurrency.Task {
                var processedTasks: [Task] = []
                for task in tasksWithReminders {
                    var newTask = task
                    let eventKitID = await eventKitManager.createReminder(for: task)
                    newTask.eventKitIdentifier = eventKitID
                    processedTasks.append(newTask)
                }
                
                await MainActor.run {
                    self.tasks.append(contentsOf: processedTasks)
                    self.debouncedSave()
                }
            }
        } else {
            debouncedSave()
        }
    }
    
    func updateTask(_ task: Task) {
        if let index = tasks.firstIndex(where: { $0.id == task.id }) {
            tasks[index] = task
            
            // Update EventKit reminder if it exists
            _Concurrency.Task {
                await eventKitManager.updateReminder(for: task)
            }
            
            debouncedSave()
        }
    }
    
    func deleteTask(_ task: Task) {
        // Delete EventKit reminder if it exists
        if let eventKitID = task.eventKitIdentifier {
            eventKitManager.deleteReminder(eventKitIdentifier: eventKitID)
        }
        
        tasks.removeAll { $0.id == task.id }
        debouncedSave()
        
        // Optimized cloud deletion
        _Concurrency.Task {
            await CloudKitManager.shared.deleteTask(task.id)
        }
    }
    
    func toggleTaskCompletion(_ task: Task) {
        var updatedTask = task
        updatedTask.isCompleted.toggle()

        // Enhanced haptic feedback based on completion state
        if updatedTask.isCompleted {
            HapticManager.shared.taskCompleted()

            // Cancel notification if task is completed early
            if let eventKitID = task.eventKitIdentifier {
                eventKitManager.deleteReminder(eventKitIdentifier: eventKitID)
                print("ðŸ”” Cancelled notification for completed task: \(task.title)")
            }

            // Present mood picker
            moodPickerTask = updatedTask
        } else {
            HapticManager.shared.buttonPressed()

            // Reset completion metadata when uncompleting
            updatedTask.completedMood = nil
            updatedTask.completedAt = nil

            // Reschedule notification if task is uncompleted and has a future reminder
            if let reminderDate = task.reminderAt, reminderDate > Date() {
                _Concurrency.Task {
                    let eventKitID = await eventKitManager.createReminder(for: updatedTask)
                    await MainActor.run {
                        updatedTask.eventKitIdentifier = eventKitID
                        self.updateTask(updatedTask)
                    }
                }
                print("ðŸ”” Rescheduled notification for uncompleted task: \(task.title)")
            }
        }

        updateTask(updatedTask)
    }

    func finalizeTaskCompletion(_ task: Task, mood: MoodType?) {
        var updatedTask = task
        updatedTask.completedMood = mood
        if updatedTask.completedAt == nil {
            updatedTask.completedAt = Date()
        }
        updateTask(updatedTask)

        DispatchQueue.main.asyncAfter(deadline: .now() + 1.5) {
            self.archiveCompletedTask(updatedTask)
        }

        moodPickerTask = nil
    }
    
    // MARK: - Completed Tasks Management
    
    private func archiveCompletedTask(_ task: Task) {
        // Remove from main tasks list
        tasks.removeAll { $0.id == task.id }
        
        // Add to completed tasks list
        var completedTasks = getCompletedTasks()
        completedTasks.append(task)
        saveCompletedTasks(completedTasks)
        
        // Save the updated main tasks list
        debouncedSave()
    }
    
    func getCompletedTasks() -> [Task] {
        if let data = UserDefaults.standard.data(forKey: "CompletedTasks"),
           let decoded = try? JSONDecoder().decode([Task].self, from: data) {
            return decoded
        }
        return []
    }
    
    private func saveCompletedTasks(_ completedTasks: [Task]) {
        if let encoded = try? JSONEncoder().encode(completedTasks) {
            UserDefaults.standard.set(encoded, forKey: "CompletedTasks")
        }
    }
    
    func deleteCompletedTask(_ task: Task) {
        var completedTasks = getCompletedTasks()
        completedTasks.removeAll { $0.id == task.id }
        saveCompletedTasks(completedTasks)
    }
    
    func addTaskList(_ list: TaskList) {
        taskLists.append(list)
        saveTaskLists()
    }
    
    // MARK: - Optimized Computed Properties with Caching
    
    private var _cachedTodayTasks: [Task]?
    private var _todayTasksCacheTime: Date?
    
    var todayTasks: [Task] {
        // Cache today's tasks for 30 seconds to avoid repeated computation
        let now = Date()
        if let cacheTime = _todayTasksCacheTime,
           let cached = _cachedTodayTasks,
           now.timeIntervalSince(cacheTime) < 30 {
            return cached
        }
        
        let optimalCount = taskScheduler.getOptimalTaskCount(for: taskScheduler.currentMood)
        let result = taskScheduler.optimizeTaskSchedule(tasks: tasks, maxTasks: optimalCount)
        
        _cachedTodayTasks = result
        _todayTasksCacheTime = now
        
        return result
    }
    
    var upcomingTasks: [Task] {
        let today = Calendar.current.startOfDay(for: Date())
        let nextWeek = Calendar.current.date(byAdding: .day, value: 7, to: today)!
        return tasks.filter { task in
            guard let reminderAt = task.reminderAt else { return false }
            return reminderAt >= today && reminderAt < nextWeek && !task.isCompleted
        }
    }
    
    var importantTasks: [Task] {
        return tasks.filter { $0.priority == .high && !$0.isCompleted }
    }
    
    var completedTasks: [Task] {
        return tasks.filter { $0.isCompleted }
    }
    
    func toggleTaskFlag(_ task: Task) {
        var updatedTask = task
        updatedTask.isFlagged.toggle()
        updateTask(updatedTask)
    }
    
    func updateCurrentMood(_ mood: MoodType) {
        taskScheduler.updateCurrentMood(mood)
        
        // Clear cache when mood changes
        _cachedTodayTasks = nil
        _todayTasksCacheTime = nil
        
        // Optimize tasks without immediate save
        autoOptimizeTasks()
    }
    
    func autoOptimizeTasks() {
        let optimalCount = taskScheduler.getOptimalTaskCount(for: taskScheduler.currentMood)
        let optimizedTasks = taskScheduler.optimizeTaskSchedule(tasks: tasks, maxTasks: optimalCount)
        
        tasks = optimizedTasks
        debouncedSave()
    }
    
    // MARK: - Optimized Persistence
    
    private func debouncedSave() {
        saveDebounceTimer?.invalidate()
        saveDebounceTimer = Timer.scheduledTimer(withTimeInterval: 0.5, repeats: false) { _ in
            _Concurrency.Task { @MainActor in
                self.saveTasksAndSync()
            }
        }
    }
    
    private func saveTasksAndSync() {
        saveTasksToUserDefaults()
        
        // Background cloud sync
        _Concurrency.Task {
            await CloudKitManager.shared.saveTasks(tasks)
        }
    }
    
    private func saveTasksToUserDefaults() {
        if let encoded = try? JSONEncoder().encode(tasks) {
            UserDefaults.standard.set(encoded, forKey: "SavedTasks")
        }
    }
    
    private func saveTaskLists() {
        if let encoded = try? JSONEncoder().encode(taskLists) {
            UserDefaults.standard.set(encoded, forKey: "SavedTaskLists")
        }
    }
    
    private func loadFromUserDefaults() {
        if let data = UserDefaults.standard.data(forKey: "SavedTasks"),
           let decoded = try? JSONDecoder().decode([Task].self, from: data) {
            tasks = decoded
        }
        
        if let data = UserDefaults.standard.data(forKey: "SavedTaskLists"),
           let decoded = try? JSONDecoder().decode([TaskList].self, from: data) {
            taskLists = decoded
        }
    }
    
    // MARK: - CloudKit Integration
    
    private func loadFromCloud() {
        _Concurrency.Task {
            let cloudTasks = await CloudKitManager.shared.fetchTasks()
            await MainActor.run {
                // Merge cloud tasks with local tasks, avoiding duplicates
                let localTaskIds = Set(tasks.map { $0.id })
                let newCloudTasks = cloudTasks.filter { !localTaskIds.contains($0.id) }
                
                if !newCloudTasks.isEmpty {
                    addTasks(newCloudTasks)
                }
            }
        }
    }
    
    func syncWithCloud() {
        loadFromCloud()
    }
    
    // MARK: - Testing Functions (Debug only)
    
    #if DEBUG
    func testNotification() {
        _Concurrency.Task {
            await eventKitManager.testMooDoNotification()
        }
    }
    #endif
    
    // MARK: - Memory Management
    
    func clearCaches() {
        // Clear cached computed properties
        _cachedTodayTasks = nil
        _todayTasksCacheTime = nil
        
        // Cancel pending operations
        saveDebounceTimer?.invalidate()
        saveDebounceTimer = nil
        
        print("ðŸ§¹ TaskManager caches cleared")
    }
}

class MoodManager: ObservableObject {
    @Published var moodEntries: [MoodEntry] = []
    @Published var currentMood: MoodType = .calm
    
    var latestMoodEntry: MoodEntry? {
        moodEntries.sorted(by: { $0.timestamp > $1.timestamp }).first
    }
    
    init() {
        loadSampleData()
        loadFromCloud()
        updateCurrentMoodFromEntries()
    }
    
    func addMoodEntry(_ entry: MoodEntry) {
        moodEntries.append(entry)
        updateCurrentMoodFromEntries()
        saveMoodEntries()
        saveToCloud()
    }
    
    func updateCurrentMood(_ mood: MoodType) {
        currentMood = mood
    }
    
    private func updateCurrentMoodFromEntries() {
        if let latestEntry = latestMoodEntry {
            currentMood = latestEntry.mood
        }
    }
    
    func updateMoodEntry(_ entry: MoodEntry) {
        if let index = moodEntries.firstIndex(where: { $0.id == entry.id }) {
            moodEntries[index] = entry
            saveMoodEntries()
            saveToCloud()
        }
    }
    
    func deleteMoodEntry(_ entry: MoodEntry) {
        moodEntries.removeAll { $0.id == entry.id }
        saveMoodEntries()
        deleteFromCloud(entry.id)
    }
    
    private func saveMoodEntries() {
        if let encoded = try? JSONEncoder().encode(moodEntries) {
            UserDefaults.standard.set(encoded, forKey: "SavedMoodEntries")
        }
    }
    
    // MARK: - CloudKit Integration
    
    private func saveToCloud() {
        _Concurrency.Task {
            await CloudKitManager.shared.saveMoodEntries(moodEntries)
        }
    }
    
    private func loadFromCloud() {
        _Concurrency.Task {
            let cloudEntries = await CloudKitManager.shared.fetchMoodEntries()
            await MainActor.run {
                // Merge cloud entries with local entries, avoiding duplicates
                let localEntryIds = Set(moodEntries.map { $0.id })
                let newCloudEntries = cloudEntries.filter { !localEntryIds.contains($0.id) }
                moodEntries.append(contentsOf: newCloudEntries)
                saveMoodEntries() // Save merged data locally
            }
        }
    }
    
    private func deleteFromCloud(_ entryId: UUID) {
        _Concurrency.Task {
            await CloudKitManager.shared.deleteMoodEntry(entryId)
        }
    }
    
    func syncWithCloud() {
        loadFromCloud()
    }
    
    private func loadSampleData() {
        // Load from UserDefaults first
        if let savedData = UserDefaults.standard.data(forKey: "SavedMoodEntries"),
           let decodedEntries = try? JSONDecoder().decode([MoodEntry].self, from: savedData) {
            moodEntries = decodedEntries
        } else {
            // Generate sample data for demonstration
            generateSampleMoodEntries()
        }
        updateCurrentMoodFromEntries()
    }
    
    private func generateSampleMoodEntries() {
        let calendar = Calendar.current
        let now = Date()
        
        moodEntries = [
            MoodEntry(mood: .energized, timestamp: calendar.date(byAdding: .hour, value: -2, to: now) ?? now),
            MoodEntry(mood: .focused, timestamp: calendar.date(byAdding: .hour, value: -5, to: now) ?? now),
            MoodEntry(mood: .calm, timestamp: calendar.date(byAdding: .day, value: -1, to: now) ?? now),
            MoodEntry(mood: .creative, timestamp: calendar.date(byAdding: .day, value: -1, to: now) ?? now),
            MoodEntry(mood: .stressed, timestamp: calendar.date(byAdding: .day, value: -2, to: now) ?? now),
            MoodEntry(mood: .tired, timestamp: calendar.date(byAdding: .day, value: -3, to: now) ?? now),
            MoodEntry(mood: .calm, timestamp: calendar.date(byAdding: .day, value: -4, to: now) ?? now),
        ]
        
        saveMoodEntries()
    }
}

class VoiceCheckinManager: ObservableObject {
    @Published var voiceCheckins: [VoiceCheckin] = []
    
    init() {
        loadSampleData()
        loadFromCloud()
    }
    
    func addVoiceCheckin(_ checkin: VoiceCheckin) {
        voiceCheckins.append(checkin)
        saveVoiceCheckins()
        saveToCloud()
    }
    
    func deleteVoiceCheckin(_ checkin: VoiceCheckin) {
        voiceCheckins.removeAll { $0.id == checkin.id }
        saveVoiceCheckins()
        deleteFromCloud(checkin.id)
    }
    
    private func saveVoiceCheckins() {
        if let encoded = try? JSONEncoder().encode(voiceCheckins) {
            UserDefaults.standard.set(encoded, forKey: "SavedVoiceCheckins")
        }
    }
    
    // MARK: - CloudKit Integration
    
    private func saveToCloud() {
        _Concurrency.Task {
            await CloudKitManager.shared.saveVoiceCheckins(voiceCheckins)
        }
    }
    
    private func loadFromCloud() {
        _Concurrency.Task {
            let cloudCheckins = await CloudKitManager.shared.fetchVoiceCheckins()
            await MainActor.run {
                // Merge cloud checkins with local checkins, avoiding duplicates
                let localCheckinIds = Set(voiceCheckins.map { $0.id })
                let newCloudCheckins = cloudCheckins.filter { !localCheckinIds.contains($0.id) }
                voiceCheckins.append(contentsOf: newCloudCheckins)
                saveVoiceCheckins() // Save merged data locally
            }
        }
    }
    
    private func deleteFromCloud(_ checkinId: UUID) {
        _Concurrency.Task {
            // Note: You may want to add a delete method for voice checkins in CloudKitManager
            // await CloudKitManager.shared.deleteVoiceCheckin(checkinId)
        }
    }
    
    func syncWithCloud() {
        loadFromCloud()
    }
    
    private func loadSampleData() {
        // Sample data removed for production
        voiceCheckins = []
    }
}

// MARK: - Data Managers

@MainActor
class TaskScheduler: ObservableObject {
    @Published var currentMood: MoodType = .calm
    
    func updateCurrentMood(_ mood: MoodType) {
        currentMood = mood
    }
    
    func optimizeTaskSchedule(tasks: [Task], maxTasks: Int? = nil) -> [Task] {
        // Advanced mood-based optimization system
        let today = Calendar.current.startOfDay(for: Date())
        let tomorrow = Calendar.current.date(byAdding: .day, value: 1, to: today)!
        let incompleTasks = tasks.filter { !$0.isCompleted }
        
        // Get mood-specific task preferences
        let moodPreferences = getMoodTaskPreferences(for: currentMood)
        
        // Calculate mood compatibility scores for all tasks
        let scoredTasks = incompleTasks.map { task in
            (task: task, score: calculateMoodCompatibilityScore(task: task, preferences: moodPreferences))
        }
        
        // Filter and prioritize based on multiple criteria
        let prioritizedTasks = scoredTasks.filter { scoredTask in
            let task = scoredTask.task
            let score = scoredTask.score
            
            // Special therapeutic filtering for stressed users
            if currentMood == .stressed {
                // When stressed, avoid stressful tasks entirely
                if task.emotion == .stressful {
                    return false  // Filter out stressful tasks
                }
                // Only include tasks that are calming or have good mood compatibility
                return score >= 0.5 || task.emotion == .calming || task.emotion == .energizing
            }
            
            // Normal filtering for other moods
            // Always include high-priority tasks and tasks due today
            let isHighPriority = task.priority == .high
            let isDueToday = (task.reminderAt != nil && 
                             task.reminderAt! >= today && 
                             task.reminderAt! < tomorrow) ||
                            (task.deadlineAt != nil && 
                             task.deadlineAt! >= today && 
                             task.deadlineAt! < tomorrow)
            let hasGoodMoodMatch = score >= 0.6
            
            return isHighPriority || isDueToday || hasGoodMoodMatch
        }
        
        // Sort by comprehensive scoring system
        let optimizedTasks = prioritizedTasks.sorted { scored1, scored2 in
            let task1 = scored1.task
            let task2 = scored2.task
            let score1 = scored1.score
            let score2 = scored2.score
            
            // 1. Urgent tasks first (due today + high priority)
            let urgent1 = isUrgent(task: task1, today: today, tomorrow: tomorrow)
            let urgent2 = isUrgent(task: task2, today: today, tomorrow: tomorrow)
            
            if urgent1 && !urgent2 { return true }
            if !urgent1 && urgent2 { return false }
            
            // 2. Mood compatibility score
            if (score1 - score2) > 0.1 || (score2 - score1) > 0.1 {
                return score1 > score2
            }
            
            // 3. Priority level
            if task1.priority != task2.priority {
                return task1.priority.numericValue > task2.priority.numericValue
            }
            
            // 4. Time sensitivity
            let time1 = task1.reminderAt ?? Date.distantFuture
            let time2 = task2.reminderAt ?? Date.distantFuture
            
            return time1 < time2
        }
        
        // Apply mood-specific task count limits
        let optimalCount = maxTasks ?? getOptimalTaskCount(for: currentMood)
        let finalTasks = Array(optimizedTasks.prefix(optimalCount).map { $0.task })
        
        return finalTasks
    }
    
    private func getMoodTaskPreferences(for mood: MoodType) -> MoodTaskPreferences {
        switch mood {
        case .energized:
            return MoodTaskPreferences(
                preferredEmotions: [.energizing, .creative, .focused],
                preferredPriorities: [.high, .medium],
                timePreference: .flexible,
                creativityBoost: 1.3,
                focusCapacity: 1.2
            )
        case .calm:
            return MoodTaskPreferences(
                preferredEmotions: [.calming, .routine],
                preferredPriorities: [.low, .medium],
                timePreference: .morning,
                creativityBoost: 0.8,
                focusCapacity: 1.0
            )
        case .focused:
            return MoodTaskPreferences(
                preferredEmotions: [.focused, .routine],
                preferredPriorities: [.high, .medium],
                timePreference: .concentrated,
                creativityBoost: 0.9,
                focusCapacity: 1.5
            )
        case .stressed:
            return MoodTaskPreferences(
                preferredEmotions: [.calming, .routine],
                preferredPriorities: [.low],
                timePreference: .gentle,
                creativityBoost: 0.5,
                focusCapacity: 0.7
            )
        case .creative:
            return MoodTaskPreferences(
                preferredEmotions: [.creative, .calming, .focused],
                preferredPriorities: [.medium, .high],
                timePreference: .flexible,
                creativityBoost: 1.5,
                focusCapacity: 1.1
            )
        case .tired:
            return MoodTaskPreferences(
                preferredEmotions: [.calming],
                preferredPriorities: [.low],
                timePreference: .gentle,
                creativityBoost: 0.3,
                focusCapacity: 0.5
            )
        }
    }
    
    private func calculateMoodCompatibilityScore(task: Task, preferences: MoodTaskPreferences) -> Double {
        var score: Double = 0.0
        
        // Emotion compatibility (40% weight)
        if preferences.preferredEmotions.contains(task.emotion) {
            score += 0.4
        } else {
            score += 0.1 // Partial credit for non-conflicting emotions
        }
        
        // Priority alignment (30% weight)
        if preferences.preferredPriorities.contains(task.priority) {
            score += 0.3
        } else if task.priority == .high && currentMood != .stressed {
            score += 0.2 // High priority tasks get partial credit unless stressed
        }
        
        // Time sensitivity (20% weight) - consider both reminder and deadline
        if let deadlineAt = task.deadlineAt {
            let timeScore = calculateTimeCompatibilityScore(reminderAt: deadlineAt, preference: preferences.timePreference)
            score += timeScore * 0.2
        } else if let reminderAt = task.reminderAt {
            let timeScore = calculateTimeCompatibilityScore(reminderAt: reminderAt, preference: preferences.timePreference)
            score += timeScore * 0.15
        } else {
            score += 0.1 // No deadline gives moderate flexibility
        }
        
        // Special boosts (10% weight)
        if task.emotion == .creative {
            score += (preferences.creativityBoost - 1.0) * 0.05
        }
        if task.emotion == .focused {
            score += (preferences.focusCapacity - 1.0) * 0.05
        }
        
        return max(0.0, min(1.0, score))
    }
    
    private func calculateTimeCompatibilityScore(reminderAt: Date, preference: TimePreference) -> Double {
        let calendar = Calendar.current
        let hour = calendar.component(.hour, from: reminderAt)
        
        switch preference {
        case .morning:
            return hour < 12 ? 1.0 : 0.3
        case .concentrated:
            return (hour >= 9 && hour <= 11) || (hour >= 14 && hour <= 16) ? 1.0 : 0.5
        case .gentle:
            return hour < 10 || hour > 18 ? 1.0 : 0.4
        case .flexible:
            return 0.8 // Generally good at any time
        }
    }
    
    private func isUrgent(task: Task, today: Date, tomorrow: Date) -> Bool {
        let isDueToday = (task.reminderAt != nil && 
                         task.reminderAt! >= today && 
                         task.reminderAt! < tomorrow) ||
                        (task.deadlineAt != nil && 
                         task.deadlineAt! >= today && 
                         task.deadlineAt! < tomorrow)
        let isHighPriority = task.priority == .high
        
        return isDueToday && isHighPriority
    }
    
    // Get optimal number of tasks based on mood with time-of-day adjustment
    func getOptimalTaskCount(for mood: MoodType) -> Int {
        let baseCount: Int
        
        switch mood {
        case .energized:
            baseCount = 8 // High energy, can handle more tasks
        case .calm:
            baseCount = 5 // Peaceful state, fewer tasks
        case .focused:
            baseCount = 6 // Good focus, moderate task count
        case .stressed:
            baseCount = 3 // Lower capacity, fewer tasks
        case .creative:
            baseCount = 7 // Creative flow, can handle variety
        case .tired:
            baseCount = 2 // Very low energy, only minimal tasks
        }
        
        // Adjust based on time of day
        let calendar = Calendar.current
        let hour = calendar.component(.hour, from: Date())
        
        let timeMultiplier: Double
        if hour < 9 {
            timeMultiplier = 0.8 // Early morning - fewer tasks
        } else if hour < 12 {
            timeMultiplier = 1.0 // Morning peak
        } else if hour < 14 {
            timeMultiplier = 0.9 // Post-lunch dip
        } else if hour < 17 {
            timeMultiplier = 1.0 // Afternoon focus
        } else if hour < 20 {
            timeMultiplier = 0.8 // Evening wind-down
        } else {
            timeMultiplier = 0.6 // Night - minimal tasks
        }
        
        return max(2, Int(Double(baseCount) * timeMultiplier))
    }
    
    // Get mood-optimized tasks for the main screen
    func getMoodOptimizedTasks(from tasks: [Task], for mood: MoodType, maxTasks: Int) -> [Task] {
        let incompleteTasks = tasks.filter { !$0.isCompleted }
        let today = Calendar.current.startOfDay(for: Date())
        let tomorrow = Calendar.current.date(byAdding: .day, value: 1, to: today)!
        
        // Score tasks based on mood compatibility
        let scoredTasks = incompleteTasks.map { task in
            (task: task, score: calculateMoodScore(task: task, mood: mood, today: today, tomorrow: tomorrow))
        }
        
        // Sort by score and take the top tasks
        let sortedTasks = scoredTasks.sorted { $0.score > $1.score }
        return Array(sortedTasks.prefix(maxTasks).map { $0.task })
    }
    
    private func calculateMoodScore(task: Task, mood: MoodType, today: Date, tomorrow: Date) -> Double {
        var score: Double = 0.0
        
        // Base score for mood-task compatibility using new unified system
        let compatibleEmotions = mood.compatibleTaskEmotions
        if compatibleEmotions.contains(task.emotion) {
            score += 1.0
        } else if mood.compatibleTaskEmotions.contains(task.emotion) {
            score += 0.7
        } else {
            score += 0.3
        }
        
        // Priority boost - but be therapeutic for stressed users
        switch task.priority {
        case .high: 
            if mood == .stressed {
                score += 0.2  // Reduced boost for high-priority tasks when stressed
            } else {
                score += 0.8
            }
        case .medium: 
            if mood == .stressed {
                score += 0.4  // Moderate boost for medium-priority tasks when stressed
            } else {
                score += 0.5
            }
        case .low: 
            if mood == .stressed {
                score += 0.8  // High boost for low-priority tasks when stressed (therapeutic)
            } else {
                score += 0.2
            }
        }
        
        // Time sensitivity boost - but be gentle with stressed users
        let isDueToday = (task.reminderAt != nil && task.reminderAt! >= today && task.reminderAt! < tomorrow) ||
                        (task.deadlineAt != nil && task.deadlineAt! >= today && task.deadlineAt! < tomorrow)
        if isDueToday {
            if mood == .stressed {
                score += 0.3  // Reduced urgency boost when stressed
            } else {
                score += 0.6
            }
        }
        
        // Mood-specific therapeutic adjustments
        switch mood {
        case .stressed:
            // Heavily favor calming, therapeutic tasks
            if task.emotion == .calming { 
                score += 0.8  // Big boost for calming tasks
            }
            if task.emotion == .energizing { 
                score += 0.6  // Good boost for energizing tasks
            }
            if task.priority == .low { 
                score += 0.5  // Additional boost for low-priority tasks
            }
            // Penalize stressful tasks
            if task.emotion == .stressful {
                score -= 0.5  // Penalty for stressful tasks
            }
            if task.priority == .high && task.emotion != .calming {
                score -= 0.3  // Penalty for high-priority non-calm tasks
            }
        case .focused:
            // Prefer challenging tasks
            if task.priority == .high { score += 0.4 }
        case .calm, .energized:
            // Balanced approach
            if task.priority == .medium { score += 0.3 }
        default:
            break
        }
        
        return max(0.0, score)  // Ensure score doesn't go negative
    }
    
    private func areEmotionsCompatible(_ emotion1: TaskEmotion, _ emotion2: TaskEmotion) -> Bool {
        let compatibilityMap: [TaskEmotion: [TaskEmotion]] = [
            .focused: [.energizing, .routine],
            .calming: [.routine],
            .energizing: [.focused, .creative],
            .stressful: [.calming],
            .creative: [.energizing, .focused],
            .routine: [.calming, .focused]
        ]
        
        return compatibilityMap[emotion2]?.contains(emotion1) ?? false
    }
}

// MARK: - Mood-Based Task Preferences

struct MoodTaskPreferences {
    let preferredEmotions: [TaskEmotion]
    let preferredPriorities: [TaskPriority]
    let timePreference: TimePreference
    let creativityBoost: Double
    let focusCapacity: Double
}

enum TimePreference {
    case morning      // Best in morning hours
    case concentrated // Best in focused work blocks
    case gentle       // Best in low-energy times
    case flexible     // Good anytime
}

// MARK: - Enhanced TaskPriority

extension TaskPriority {
    var rawValue: String {
        switch self {
        case .low: return "low"
        case .medium: return "medium" 
        case .high: return "high"
        }
    }
    
    var numericValue: Int {
        switch self {
        case .low: return 1
        case .medium: return 2
        case .high: return 3
        }
    }
}

enum SmartListType: String, CaseIterable {
    case today = "Today"
    case tomorrow = "Tomorrow"
    case thisWeek = "This Week"
    case upcoming = "Upcoming"
    case important = "Important"
    case completed = "Completed"
    case all = "All"
    
    var icon: String {
        switch self {
        case .today: return "calendar"
        case .tomorrow: return "calendar.badge.plus"
        case .thisWeek: return "calendar.badge.clock"
        case .upcoming: return "calendar.badge.clock"
        case .important: return "exclamationmark.triangle"
        case .completed: return "checkmark.circle"
        case .all: return "list.bullet"
        }
    }
    
    var color: Color {
        switch self {
        case .today: return .blue
        case .tomorrow: return .green
        case .thisWeek: return .orange
        case .upcoming: return .cyan
        case .important: return .red
        case .completed: return .gray
        case .all: return .purple
        }
    }
}

struct TaskList: Identifiable, Codable {
    var id = UUID()
    let name: String
    let colorName: String
    let icon: String
    
    var color: Color {
        switch colorName {
        case "red": return .red
        case "blue": return .blue
        case "green": return .green
        case "orange": return .orange
        case "purple": return .purple
        case "pink": return .pink
        case "yellow": return .yellow
        case "cyan": return .cyan
        default: return .blue
        }
    }
    
    init(name: String, color: Color, icon: String) {
        self.name = name
        self.icon = icon
        self.colorName = Self.colorName(for: color)
    }
    
    private static func colorName(for color: Color) -> String {
        // Simple color mapping - you might want to expand this
        if color == .red { return "red" }
        if color == .blue { return "blue" }
        if color == .green { return "green" }
        if color == .orange { return "orange" }
        if color == .purple { return "purple" }
        if color == .pink { return "pink" }
        if color == .yellow { return "yellow" }
        if color == .cyan { return "cyan" }
        return "blue"
    }
} 
